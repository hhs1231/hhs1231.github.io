<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>网络编程</title>
      <link href="/2024/10/03/5.Network-Fundamentals/"/>
      <url>/2024/10/03/5.Network-Fundamentals/</url>
      
        <content type="html"><![CDATA[<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="各层典型协议"><a href="#各层典型协议" class="headerlink" title="各层典型协议"></a>各层典型协议</h2><h3 id="网络接口与物理层"><a href="#网络接口与物理层" class="headerlink" title="网络接口与物理层"></a>网络接口与物理层</h3><p>​MAC地址：48位全球唯一，网络设备的身份标识</p><p>​ARP&#x2F;RARP</p><p>​ARP:IP地址—-&gt;MAC地址</p><p>​RARP:MAC地址—-&gt;IP地址</p><p>​PPP协议</p><p>​拨号协议(GPRS&#x2F;3G&#x2F;4G)</p><h3 id="网络层-IP层"><a href="#网络层-IP层" class="headerlink" title="网络层(IP层)"></a>网络层(IP层)</h3><p>IP: Internet protocol（IPV4&#x2F;IPV6）</p><p>ICMP：Internet控制管理协议，ping命令属于ICMP</p><p>IGMP：Internet分组管理协议，广播，组播</p><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>TCP: Transfer Control protocol传输控制协议，提供面向连接的一对一可靠数据传输协议</p><p>UDP: user Datagram Protocol用户数据报协议，提供不可靠无连接的尽力传输协议</p><p>SCTP可靠传输，TCP增强版，可实现多主机多链路通信</p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>网络访问协议HTTP&#x2F;HTTPS</p><p>邮件发送接收协议POP3（收）&#x2F;SMTP（发）、IMAP（可接收邮件的一种协议）</p><p>FTP</p><p>Telnet&#x2F;SSH远程登录</p><h4 id="嵌入式相关"><a href="#嵌入式相关" class="headerlink" title="嵌入式相关"></a>嵌入式相关</h4><p>NTP网络时钟协议</p><p>SNMP简单网络管理协议（实现对网络设备的集中式管理）</p><p>RTP&#x2F;ETSP传输音视频协议（安防监控）</p><h2 id="网络封包拆包"><a href="#网络封包拆包" class="headerlink" title="网络封包拆包"></a>网络封包拆包</h2><p>MTU：Max Transfer Unit最大传输单元，以太网中最大为1500</p><p>MSS：Maxium Segment Size和网络类型、线路、系统特性相关</p><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p>编程的接口，是一种特殊的文件描述符（对它执行IO操作的函数，read()、write()、close()等操作函数）</p><p>代表网络编程的资源</p><h3 id="socket类型"><a href="#socket类型" class="headerlink" title="socket类型"></a>socket类型</h3><h5 id="流式套接字-SOCK-STREAM"><a href="#流式套接字-SOCK-STREAM" class="headerlink" title="流式套接字 SOCK_STREAM"></a>流式套接字 SOCK_STREAM</h5><p>提供面向连接、可靠的数据传输服务，数据无差错、无重复的发送且按发送顺序接收。内设置流量控制，避免数据淹没慢的接收方。数据被看作是字节流，五长度限制</p><h5 id="数据报套接字-SOCK-DGRAM"><a href="#数据报套接字-SOCK-DGRAM" class="headerlink" title="数据报套接字 SOCK_DGRAM"></a>数据报套接字 SOCK_DGRAM</h5><p>提供无连接服务。数据包以独立数据包形式被发送，不提供无差错保证，数据可能丢失或重复，顺序发送，可能乱序接收</p><h5 id="原始套接字-SOCK-RAW"><a href="#原始套接字-SOCK-RAW" class="headerlink" title="原始套接字 SOCK_RAW"></a>原始套接字 SOCK_RAW</h5><p>可以对较低层次协议如IP、ICMP等直接访问</p><h5 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h5><p>IPV4：32为整数</p><p>IPV6：128位整数</p><p>mobileIPV6：local IP本地注册IP，roam IP漫游IP</p><p>IPV4地址：点分形式的32位整数</p><h6 id="特殊IP地址"><a href="#特殊IP地址" class="headerlink" title="特殊IP地址"></a>特殊IP地址</h6><p>局域网IP：192.XXX.XXX.XXX    10.XXX.XXX.XXX</p><p>广播IP：XXX.XXX.XXX.255   255.255.255.255全网广播</p><p>组播IP：224.XXX.XXX.XXX-239.XXX.XXX.XXX不含广播IP</p><h4 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h4><p>16位数字（1-65535）</p><p>常见端口：1-1023（FTP:21, SSH:22, HTTP:80, HTTPS:469）</p><p>保留端口：1024-5000（不建议使用）</p><p>可用：5001-65535</p><p>TCP端口和UDP端口相互独立</p><p>网络中通信为IP+端口号决定</p><h4 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h4><p>不同CPU访问内存中多字节数据的时候存在大小端问题，如CPU访问字符串数据不存在大小端问题</p><p>低对低：小端</p><p>​低端内存存放低端数据</p><p>低对高：大端</p><p>​低端内存存放高端数据</p><p>一般X86&#x2F;ARM：小端；powerpc&#x2F;mips，ARM作为路由器：大端</p><p>网络传输：大端</p><p>主机字节序转网络字节序</p><p>u_long htonl(u_long hostlong);</p><p>u_short htons(u_short short);</p><p>网络字节序转主机字节序</p><p>u_long ntohl(u_long hostlong);</p><p>u_short ntohs(u_short short);</p><h5 id="IP地址转换函数"><a href="#IP地址转换函数" class="headerlink" title="IP地址转换函数"></a>IP地址转换函数</h5><p>in_addr_t inet_addr(const char *cp);</p><p>cp:点分形式的IP地址，结果是32位整数（内部包含了字节序的转换，默认是网络字节序的模式）</p><p>仅适用于IPV4，当出错时返回-1，此函数不能用于255.255.255.255的转换</p><p>inet_pton()&#x2F;inet_ntop()</p><p>需要引用arpa&#x2F;inet.h</p><p>int inet_pton(int af, const char *src, void *dst);</p><p>适用于IPV4和IPV6，能正确处理255.255.255.255的转换</p><p>af：地址协议族（AF_INET或AF_INET6）</p><p>src：是一个指针（填写点分形式的IP地址[主要指IPV4]）</p><p>dst：转换的结果给到dst</p><p>成功为1，失败为0 </p><p>const char *inet_ntop(int af, const char *src, void *dst);</p><p>适用于IPV4和IPV6，能正确处理-1的转换</p><p>af：地址协议族（AF_INET或AF_INET6）</p><p>src：是一个指针（32位网络字节序的IP地址）</p><p>dst：输出结果为点分形式的IP地址[主要指IPV4]</p><p>成功返回非空指针，失败返回空指针</p><h2 id="TCP编程API"><a href="#TCP编程API" class="headerlink" title="TCP编程API"></a>TCP编程API</h2><h3 id="socket-创建函数"><a href="#socket-创建函数" class="headerlink" title="socket()创建函数"></a>socket()创建函数</h3><p>需要引用sys&#x2F;types.h&#x2F;sys&#x2F;socket.h</p><p>int socket(int domain, int type, int protocol);</p><p>domain：</p><p>​AF_INET                              IPV4 Internet protocol</p><p>​AF_INET6                            IPV6 Internet protocol</p><p>​AF_UNIX, AF_LOCAL         Local communication（本地属性）</p><p>​AF_NETLINK                      Kernel user interface device（内核和用户通信）</p><p>​AF_PACKET                        Low level packet interface</p><p>type：</p><p>​SOCK_STREAM:流式套接字，唯一对应TCP</p><p>​SOCK_DGRAM:数据报套接字，唯一对应UDP</p><p>​SOCK_RAW:原始套接字</p><p>protocol：一般填0，原始套接字编程时需填充</p><p>成功返回文件描述符，失败返回-1</p><h3 id="bind-绑定函数"><a href="#bind-绑定函数" class="headerlink" title="bind()绑定函数"></a>bind()绑定函数</h3><p>需要引用sys&#x2F;types.h&#x2F;sys&#x2F;socket.h</p><p>int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</p><p>sockfd：通过socket()函数拿到的fd</p><p>addr：struct sockaddr的结构体变量的地址(IPV4:sockaddr_in(man 7 ipv4),IPV6:sockaddr_in6（man 7 ipv6）,通常更通用的方法可以通过struct sockaddr_storage来编程)</p><p>addrlen：地址长度</p><p>成功返回0，失败返回-1</p><h3 id="listen-主动转被动函数"><a href="#listen-主动转被动函数" class="headerlink" title="listen()主动转被动函数"></a>listen()主动转被动函数</h3><p>需要引用sys&#x2F;types.h&#x2F;sys&#x2F;socket.h</p><p>int listen(int sockfd, int backlog);</p><p>backlog：一般填5（同时允许几路客户端和服务器进行连接，ARM最大为8）</p><p>成功返回0，失败返回-1</p><h3 id="accept-阻塞等待客户端连接请求函数"><a href="#accept-阻塞等待客户端连接请求函数" class="headerlink" title="accept()阻塞等待客户端连接请求函数"></a>accept()阻塞等待客户端连接请求函数</h3><p>需要引用sys&#x2F;types.h&#x2F;sys&#x2F;socket.h</p><p>int accept(int sockfd, struct sockaddr *addr, socklen_t addrlen);</p><p>sockfd：经过前面socket()创建并通过bind(),listen()设置过的fd</p><p>addr和addrlen：可获取客户端的IP+端口号</p><p>成功返回已经建立好新的newfd，失败返回-1</p><h3 id="connect-客户端连接函数"><a href="#connect-客户端连接函数" class="headerlink" title="connect()客户端连接函数"></a>connect()客户端连接函数</h3><p>需要引用sys&#x2F;types.h&#x2F;sys&#x2F;socket.h</p><p>int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</p><p>和bind()函数类似</p><p>成功返回0，失败返回-1</p><p>INADDR_ANY可以获取程序运行所在主机任意网卡传输过来的数据</p><h3 id="send-write-网络发送数据"><a href="#send-write-网络发送数据" class="headerlink" title="send()&#x2F;write()网络发送数据"></a>send()&#x2F;write()网络发送数据</h3><p>需要引用sys&#x2F;types.h和sys&#x2F;socket.h</p><p>ssize_t send(int sockfd, const void *buf, size_t len, int flags);</p><p>需要引用unisd.h</p><p>ssize_t write(int fd, const void *buf, size_t count);</p><p>send()比write()多一个参数flags：一般填写0（阻塞），此时和write()作用一样</p><p>MSG_DONTWAIT：非阻塞版本</p><p>MSG_OOB：用于发送TCP类型的带外数据(out-of-band)</p><h3 id="recv-read-网络接收数据"><a href="#recv-read-网络接收数据" class="headerlink" title="recv()&#x2F;read()网络接收数据"></a>recv()&#x2F;read()网络接收数据</h3><p>需要引用sys&#x2F;types.h和sys&#x2F;socket.h</p><p>ssize_t recv(int sockfd, void *buf, size_t len, int flags);</p><p>需要引用unisd.h</p><p>ssize_t read(int fd, void *buf, size_t count);</p><p>recv()比read()多一个参数flags：一般填写0（阻塞），此时和write()作用一样</p><p>MSG_DONTWAIT：非阻塞版本</p><p>MSG_OOB：用于发送TCP类型的带外数据(out-of-band)</p><p>MSG_PEEK：读完部分数据后续依旧从头开始读</p><h2 id="阻塞相关函数"><a href="#阻塞相关函数" class="headerlink" title="阻塞相关函数"></a>阻塞相关函数</h2><p>ioctl（int fd, int cmd, long arg）;</p><p>cmd:和IO相关的是FIONBIO，可决定文件描述符是否为阻塞IO</p><p>arg：非零整数即为非阻塞IO</p><p>int fcntl(int fd, int cmd, long arg);</p><p>cmd：为F_GETFL时是获取文件描述符的标志，F_SETFL是设置文件描述符的标志</p><p>函数的结果|&#x3D;O_NONBLOCK即可设置为非阻塞IO</p><h2 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h2><p>基本常识：</p><p>linux中每个进程默认情况下，最多可打开1024个文件，最多有1024个文件描述符</p><p>文件描述符的特点：</p><ol><li>非负整数</li><li>从最小可用的数字来分配</li><li>每个进程启动时默认打开0，1，2三个文件描述符</li></ol><p>多路复用针对是不止是文件描述符fd，也包括普通文件描述符fd</p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol><li>把关心的文件描述符加入到集合（fd_set：集合长度为maxfd+1，一般是4个字节的整数）中</li><li>调用select()&#x2F;poll()函数去监控集合fd_set中哪些文件描述符（阻塞等待集合中一个或者多个文件描述符有数据）</li><li>当有数据时退出select()阻塞</li><li>依次判断哪个文件描述符有数据</li><li>依次处理有数据的文件描述符上的数据</li></ol><h3 id="fd-set有关的函数"><a href="#fd-set有关的函数" class="headerlink" title="fd_set有关的函数"></a>fd_set有关的函数</h3><p>1.清零集合</p><p>void FD_ZERO(fd_set *fdset)</p><p>2.把fd加入集合</p><p>void FD_SET(int fd, fd_set *fdset)</p><p>3.从集合清除fd</p><p>void FD_CLR(int fd, fd_set *fdset)</p><p>4.判断fd是否在集合中</p><p>int FD_ISSET(int fd, fd_set *fdset)</p><h3 id="阻塞函数"><a href="#阻塞函数" class="headerlink" title="阻塞函数"></a>阻塞函数</h3><p>int select(int nfds, fd_set *readfds, fd_set, *writefds, fd_set *exceptfds, struct timeval *timeout)</p><p>nfds：fd_set集合的长度即maxfd+1</p><p>readfds：读集合</p><p>writefds：写集合，一般为NULL</p><p>exceptfds：异常集合，一般填NULL，除非有带外数据</p><p>timeout：超时阻塞时间</p><p><strong>select()退出后集合中全是有数据的集合</strong></p><p>struct timeval{</p><p>​long tv_sec;&#x2F;&#x2F;秒</p><p>​long tv_usec;&#x2F;&#x2F;微秒</p><p>}</p><p>1秒（s）&#x3D;10^3毫秒（ms）&#x3D;10^6微秒（us）&#x3D;10^9纳秒（ns）&#x3D;10^12纳秒（ps）</p><p>if(FD_SET(fd, rset)){</p><p>1.如果此fd为监听套接字则代表有新的客户端连接，则accept()接收</p><p>2.如果是已建立连接的套接字则读数据</p><p>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo-matery版本</title>
      <link href="/2024/10/03/Create-Blog/"/>
      <url>/2024/10/03/Create-Blog/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo-matery版本"><a href="#hexo-matery版本" class="headerlink" title="hexo-matery版本"></a>hexo-matery版本</h1><h2 id="安装博客底层hexo"><a href="#安装博客底层hexo" class="headerlink" title="安装博客底层hexo"></a>安装博客底层hexo</h2><p>安装node.js和Git</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">node</span> -v和npm -v检查是否安装好<span class="token function">npm</span> <span class="token function">install</span> hexo-cli <span class="token parameter variable">-g</span>hexo init blog<span class="token builtin class-name">cd</span> blog<span class="token function">npm</span> <span class="token function">install</span>hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="下载hexo-theme-matery主题"><a href="#下载hexo-theme-matery主题" class="headerlink" title="下载hexo-theme-matery主题"></a>下载hexo-theme-matery主题</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://codeload.github.com/blinkfox/hexo-theme-matery/zip/master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将文件解压缩到hexo中的theme中</p><h2 id="修改-config-yml"><a href="#修改-config-yml" class="headerlink" title="修改_config.yml"></a>修改_config.yml</h2><p>打开hexo根目录中的_config.yml</p><p>修改theme的值为hexo-theme-matery</p><p>url修改为网站的url</p><p>per_page分页数值建议修改为6的倍数</p><p>language修改为zh-CN</p><h2 id="添加其他页面"><a href="#添加其他页面" class="headerlink" title="添加其他页面"></a>添加其他页面</h2><h3 id="分类categories页面"><a href="#分类categories页面" class="headerlink" title="分类categories页面"></a>分类categories页面</h3><h4 id="新建"><a href="#新建" class="headerlink" title="新建"></a>新建</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page <span class="token string">"categories"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="页面内容设置"><a href="#页面内容设置" class="headerlink" title="页面内容设置"></a>页面内容设置</h4><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> categories<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-30 17:25:30</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"categories"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"categories"</span><span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="标签tags页面"><a href="#标签tags页面" class="headerlink" title="标签tags页面"></a>标签tags页面</h3><h4 id="新建-1"><a href="#新建-1" class="headerlink" title="新建"></a>新建</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page <span class="token string">"tages"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="页面内容设置-1"><a href="#页面内容设置-1" class="headerlink" title="页面内容设置"></a>页面内容设置</h4><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> tags<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-30 18:23:38</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"tags"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"tags"</span><span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="关于我-about-页"><a href="#关于我-about-页" class="headerlink" title="关于我 about 页"></a>关于我 about 页</h3><h4 id="新建-2"><a href="#新建-2" class="headerlink" title="新建"></a>新建</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page <span class="token string">"about"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="页面内容设置-2"><a href="#页面内容设置-2" class="headerlink" title="页面内容设置"></a>页面内容设置</h4><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> about<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-30 17:25:30</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"about"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"about"</span><span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="友情连接-friends-页（可选的）"><a href="#友情连接-friends-页（可选的）" class="headerlink" title="友情连接 friends 页（可选的）"></a>友情连接 friends 页（可选的）</h3><h4 id="新建-3"><a href="#新建-3" class="headerlink" title="新建"></a>新建</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page <span class="token string">"friends"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="页面内容设置-3"><a href="#页面内容设置-3" class="headerlink" title="页面内容设置"></a>页面内容设置</h4><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> friends<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-12-12 21:25:30</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"friends"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"friends"</span><span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>添加json文件</p><p>在source目录下新建_data目录，在 _data目录下新建friends.json，并填写类似内容</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">[</span><span class="token punctuation">&#123;</span>    <span class="token property">"avatar"</span><span class="token operator">:</span> <span class="token string">"http://image.luokangyuan.com/1_qq_27922023.jpg"</span><span class="token punctuation">,</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"码酱"</span><span class="token punctuation">,</span>    <span class="token property">"introduction"</span><span class="token operator">:</span> <span class="token string">"我不是大佬，只是在追寻大佬的脚步"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"http://luokangyuan.com/"</span><span class="token punctuation">,</span>    <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"前去学习"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>    <span class="token property">"avatar"</span><span class="token operator">:</span> <span class="token string">"http://image.luokangyuan.com/4027734.jpeg"</span><span class="token punctuation">,</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"闪烁之狐"</span><span class="token punctuation">,</span>    <span class="token property">"introduction"</span><span class="token operator">:</span> <span class="token string">"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"https://blinkfox.github.io/"</span><span class="token punctuation">,</span>    <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"前去学习"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>    <span class="token property">"avatar"</span><span class="token operator">:</span> <span class="token string">"http://image.luokangyuan.com/avatar.jpg"</span><span class="token punctuation">,</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"ja_rome"</span><span class="token punctuation">,</span>    <span class="token property">"introduction"</span><span class="token operator">:</span> <span class="token string">"平凡的脚步也可以走出伟大的行程"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"ttps://me.csdn.net/jlh912008548"</span><span class="token punctuation">,</span>    <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"前去学习"</span><span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h3><p>由于 Hexo 自带的代码高亮主题显示不好看，所以主题中使用到了 <a href="https://github.com/ele828/hexo-prism-plugin">hexo-prism-plugin</a> 的 Hexo 插件来做代码高亮，安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> i <span class="token parameter variable">-S</span> hexo-prism-plugin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后，修改 Hexo 根目录下 <code>_config.yml</code> 文件中 <code>highlight.enable</code> 的值为 <code>false</code>，并新增 <code>prism</code> 插件相关的配置，主要配置如下：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">highlight</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">prism_plugin</span><span class="token punctuation">:</span>  <span class="token key atrule">mode</span><span class="token punctuation">:</span> <span class="token string">'preprocess'</span>    <span class="token comment"># realtime/preprocess</span>  <span class="token key atrule">theme</span><span class="token punctuation">:</span> <span class="token string">'tomorrow'</span>  <span class="token key atrule">line_number</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>    <span class="token comment"># default false</span>  custom_css<span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>本主题中还使用到了 <a href="https://github.com/wzpan/hexo-generator-search">hexo-generator-search</a> 的 Hexo 插件来做内容搜索，安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-generator-search <span class="token parameter variable">--save</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">search</span><span class="token punctuation">:</span>  <span class="token key atrule">path</span><span class="token punctuation">:</span> search.xml  <span class="token key atrule">field</span><span class="token punctuation">:</span> post<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="中文链接转拼音（可选的）"><a href="#中文链接转拼音（可选的）" class="headerlink" title="中文链接转拼音（可选的）"></a>中文链接转拼音（可选的）</h3><p>如果你的文章名称是中文的，那么 Hexo 默认生成的永久链接也会有中文，这样不利于 <code>SEO</code>，且 <code>gitment</code> 评论对中文链接也不支持。我们可以用 <a href="https://github.com/viko16/hexo-permalink-pinyin">hexo-permalink-pinyin</a> Hexo 插件使在生成文章时生成中文拼音的永久链接。</p><p>安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> i hexo-permalink-pinyin <span class="token parameter variable">--save</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">permalink_pinyin</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">separator</span><span class="token punctuation">:</span> <span class="token string">'-'</span> <span class="token comment"># default: '-'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="文章字数统计插件（可选的）"><a href="#文章字数统计插件（可选的）" class="headerlink" title="文章字数统计插件（可选的）"></a>文章字数统计插件（可选的）</h3><p>如果你想要在文章中显示文章字数、阅读时长信息，可以安装 <a href="https://github.com/willin/hexo-wordcount">hexo-wordcount</a>插件。</p><p>安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> i <span class="token parameter variable">--save</span> hexo-wordcount<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后只需在本主题下的 <code>_config.yml</code> 文件中，激活以下配置项即可：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">wordCount</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">false</span> <span class="token comment"># 将这个值设置为 true 即可.</span>  <span class="token key atrule">postWordCount</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">min2read</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">totalCount</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="添加-RSS-订阅支持（可选的）"><a href="#添加-RSS-订阅支持（可选的）" class="headerlink" title="添加 RSS 订阅支持（可选的）"></a>添加 RSS 订阅支持（可选的）</h3><p>本主题中还使用到了 <a href="https://github.com/hexojs/hexo-generator-feed">hexo-generator-feed</a> 的 Hexo 插件来做 <code>RSS</code>，安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-generator-feed <span class="token parameter variable">--save</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">feed</span><span class="token punctuation">:</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> atom  <span class="token key atrule">path</span><span class="token punctuation">:</span> atom.xml  <span class="token key atrule">limit</span><span class="token punctuation">:</span> <span class="token number">20</span>  <span class="token key atrule">hub</span><span class="token punctuation">:</span>  <span class="token key atrule">content</span><span class="token punctuation">:</span>  <span class="token key atrule">content_limit</span><span class="token punctuation">:</span> <span class="token number">140</span>  <span class="token key atrule">content_limit_delim</span><span class="token punctuation">:</span> <span class="token string">' '</span>  <span class="token key atrule">order_by</span><span class="token punctuation">:</span> <span class="token punctuation">-</span>date<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行 <code>hexo clean &amp;&amp; hexo g</code> 重新生成博客文件，然后在 <code>public</code> 文件夹中即可看到 <code>atom.xml</code> 文件，说明你已经安装成功了。</p><h3 id="修改页脚"><a href="#修改页脚" class="headerlink" title="修改页脚"></a>修改页脚</h3><p>页脚信息可能需要做定制化修改，而且它不便于做成配置信息，所以可能需要你自己去再修改和加工。修改的地方在主题文件的 <code>/layout/_partial/footer.ejs</code> 文件中，包括站点、使用的主题、访问量等。</p><h3 id="修改社交链接"><a href="#修改社交链接" class="headerlink" title="修改社交链接"></a>修改社交链接</h3><p>在主题的 <code>_config.yml</code> 文件中，默认支持 <code>QQ</code>、<code>GitHub</code> 和邮箱的配置，你可以在主题文件的 <code>/layout/_partial/social-link.ejs</code> 文件中，新增、修改你需要的社交链接地址，增加链接可参考如下代码：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://github.com/blinkfox<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>tooltipped<span class="token punctuation">"</span></span> <span class="token attr-name">target</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>_blank<span class="token punctuation">"</span></span> <span class="token attr-name">data-tooltip</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>访问我的GitHub<span class="token punctuation">"</span></span> <span class="token attr-name">data-position</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>top<span class="token punctuation">"</span></span> <span class="token attr-name">data-delay</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>50<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>i</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>fa fa-github<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>i</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其中，社交图标（如：<code>fa-github</code>）你可以在 <a href="https://fontawesome.com/icons">Font Awesome</a> 中搜索找到。以下是常用社交图标的标识，供你参考：</p><ul><li>Facebook: <code>fa-facebook</code></li><li>Twitter: <code>fa-twitter</code></li><li>Google-plus: <code>fa-google-plus</code></li><li>Linkedin: <code>fa-linkedin</code></li><li>Tumblr: <code>fa-tumblr</code></li><li>Medium: <code>fa-medium</code></li><li>Slack: <code>fa-slack</code></li><li>新浪微博: <code>fa-weibo</code></li><li>微信: <code>fa-wechat</code></li><li>QQ: <code>fa-qq</code></li></ul><blockquote><p><strong>注意</strong>: 本主题中使用的 <code>Font Awesome</code> 版本为 <code>4.7.0</code>。</p></blockquote><h3 id="修改打赏的二维码图片"><a href="#修改打赏的二维码图片" class="headerlink" title="修改打赏的二维码图片"></a>修改打赏的二维码图片</h3><p>在主题文件的 <code>source/medias/reward</code> 文件中，你可以替换成你的的微信和支付宝的打赏二维码图片。</p><h3 id="配置音乐播放器（可选的）"><a href="#配置音乐播放器（可选的）" class="headerlink" title="配置音乐播放器（可选的）"></a>配置音乐播放器（可选的）</h3><p>要支持音乐播放，就必须开启音乐的播放配置和音乐数据的文件。</p><p>首先，在你的博客 <code>source</code> 目录下的 <code>_data</code> 目录（没有的话就新建一个）中新建 <code>musics.json</code> 文件，文件内容如下所示：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">[</span><span class="token punctuation">&#123;</span><span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"五月雨变奏电音"</span><span class="token punctuation">,</span><span class="token property">"artist"</span><span class="token operator">:</span> <span class="token string">"AnimeVibe"</span><span class="token punctuation">,</span><span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"http://xxx.com/music1.mp3"</span><span class="token punctuation">,</span><span class="token property">"cover"</span><span class="token operator">:</span> <span class="token string">"http://xxx.com/music-cover1.png"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Take me hand"</span><span class="token punctuation">,</span><span class="token property">"artist"</span><span class="token operator">:</span> <span class="token string">"DAISHI DANCE,Cecile Corbel"</span><span class="token punctuation">,</span><span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"/medias/music/music2.mp3"</span><span class="token punctuation">,</span><span class="token property">"cover"</span><span class="token operator">:</span> <span class="token string">"/medias/music/cover2.png"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Shape of You"</span><span class="token punctuation">,</span><span class="token property">"artist"</span><span class="token operator">:</span> <span class="token string">"J.Fla"</span><span class="token punctuation">,</span><span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"http://xxx.com/music3.mp3"</span><span class="token punctuation">,</span><span class="token property">"cover"</span><span class="token operator">:</span> <span class="token string">"http://xxx.com/music-cover3.png"</span><span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>注</strong>：以上 JSON 中的属性：<code>name</code>、<code>artist</code>、<code>url</code>、<code>cover</code> 分别表示音乐的名称、作者、音乐文件地址、音乐封面。</p></blockquote><p>然后，在主题的 <code>_config.yml</code> 配置文件中激活配置即可：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># 是否在首页显示音乐.</span><span class="token key atrule">music</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">showTitle</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>  <span class="token key atrule">title</span><span class="token punctuation">:</span> 听听音乐  <span class="token key atrule">fixed</span><span class="token punctuation">:</span> <span class="token boolean important">false</span> <span class="token comment"># 是否开启吸底模式</span>  <span class="token key atrule">autoplay</span><span class="token punctuation">:</span> <span class="token boolean important">false</span> <span class="token comment"># 是否自动播放</span>  <span class="token key atrule">theme</span><span class="token punctuation">:</span> <span class="token string">'#42b983'</span>  <span class="token key atrule">loop</span><span class="token punctuation">:</span> <span class="token string">'all'</span> <span class="token comment"># 音频循环播放, 可选值: 'all', 'one', 'none'</span>  <span class="token key atrule">order</span><span class="token punctuation">:</span> <span class="token string">'list'</span> <span class="token comment"># 音频循环顺序, 可选值: 'list', 'random'</span>  <span class="token key atrule">preload</span><span class="token punctuation">:</span> <span class="token string">'auto'</span> <span class="token comment"># 预加载，可选值: 'none', 'metadata', 'auto'</span>  <span class="token key atrule">volume</span><span class="token punctuation">:</span> <span class="token number">0.7</span> <span class="token comment"># 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效</span>  <span class="token key atrule">listFolded</span><span class="token punctuation">:</span> <span class="token boolean important">false</span> <span class="token comment"># 列表默认折叠</span>  <span class="token key atrule">listMaxHeight</span><span class="token punctuation">:</span> <span class="token comment"># 列表最大高度</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="文章-Front-matter-介绍"><a href="#文章-Front-matter-介绍" class="headerlink" title="文章 Front-matter 介绍"></a>文章 Front-matter 介绍</h2><h3 id="Front-matter-选项详解"><a href="#Front-matter-选项详解" class="headerlink" title="Front-matter 选项详解"></a>Front-matter 选项详解</h3><p><code>Front-matter</code> 选项中的所有内容均为<strong>非必填</strong>的。但我仍然建议至少填写 <code>title</code> 和 <code>date</code> 的值。</p><table><thead><tr><th align="left">配置选项</th><th align="left">默认值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">title</td><td align="left"><code>Markdown</code> 的文件标题</td><td align="left">文章标题，强烈建议填写此选项</td></tr><tr><td align="left">date</td><td align="left">文件创建时的日期时间</td><td align="left">发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td align="left">author</td><td align="left">根 <code>_config.yml</code> 中的 <code>author</code></td><td align="left">文章作者</td></tr><tr><td align="left">img</td><td align="left"><code>featureImages</code> 中的某个值</td><td align="left">文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <code>http://xxx.com/xxx.jpg</code></td></tr><tr><td align="left">top</td><td align="left"><code>true</code></td><td align="left">推荐文章（文章是否置顶），如果 <code>top</code> 值为 <code>true</code>，则会作为首页推荐文章</td></tr><tr><td align="left">cover</td><td align="left"><code>false</code></td><td align="left"><code>v1.0.2</code>版本新增，表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td align="left">coverImg</td><td align="left">无</td><td align="left"><code>v1.0.2</code>版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td align="left">password</td><td align="left">无</td><td align="left">文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <code>password</code> 的值，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。前提是在主题的 <code>config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td></tr><tr><td align="left">toc</td><td align="left"><code>true</code></td><td align="left">是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <code>config.yml</code> 中激活了 <code>toc</code> 选项</td></tr><tr><td align="left">mathjax</td><td align="left"><code>false</code></td><td align="left">是否开启数学公式支持 ，本文章是否开启 <code>mathjax</code>，且需要在主题的 <code>_config.yml</code> 文件中也需要开启才行</td></tr><tr><td align="left">summary</td><td align="left">无</td><td align="left">文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td align="left">categories</td><td align="left">无</td><td align="left">文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td align="left">tags</td><td align="left">无</td><td align="left">文章标签，一篇文章可以多个标签</td></tr></tbody></table><blockquote><p><strong>注意</strong>:</p><ol><li>如果 <code>img</code> 属性不填写的话，文章特色图会根据文章标题的 <code>hashcode</code> 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图<strong>各有特色</strong>。</li><li><code>date</code> 的值尽量保证每篇文章是唯一的，因为本主题中 <code>Gitalk</code> 和 <code>Gitment</code> 识别 <code>id</code> 是通过 <code>date</code> 的值来作为唯一标识的。</li><li>如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 <code>_config.yml</code> 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：<a href="http://tool.oschina.net/encrypt?type=2">开源中国在线工具</a>、<a href="http://encode.chahuo.com/">chahuo</a>、<a href="http://tool.chinaz.com/tools/hash.aspx">站长工具</a>。</li></ol></blockquote><p>以下为文章的 <code>Front-matter</code> 示例。</p><h3 id="最简示例"><a href="#最简示例" class="headerlink" title="最简示例"></a>最简示例</h3><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> typora<span class="token punctuation">-</span>vue<span class="token punctuation">-</span>theme主题介绍<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-07 09:25:00</span><span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="最全示例"><a href="#最全示例" class="headerlink" title="最全示例"></a>最全示例</h3><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> typora<span class="token punctuation">-</span>vue<span class="token punctuation">-</span>theme主题介绍<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-07 09:25:00</span><span class="token key atrule">author</span><span class="token punctuation">:</span> 赵奇<span class="token key atrule">img</span><span class="token punctuation">:</span> /source/images/xxx.jpg<span class="token key atrule">top</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token key atrule">cover</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token key atrule">coverImg</span><span class="token punctuation">:</span> /images/1.jpg<span class="token key atrule">password</span><span class="token punctuation">:</span> 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92<span class="token key atrule">toc</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">mathjax</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">summary</span><span class="token punctuation">:</span> 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要<span class="token key atrule">categories</span><span class="token punctuation">:</span> Markdown<span class="token key atrule">tags</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> Typora  <span class="token punctuation">-</span> Markdown<span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="效果截图"><a href="#效果截图" class="headerlink" title="效果截图"></a>效果截图</h2><p><img src="https://statics.sh1a.qingstor.com/2018/12/02/matery-20181202-1.png" alt="首页"></p><p><strong>首页</strong></p><p><img src="https://statics.sh1a.qingstor.com/2018/12/02/matery-20181202-2.png" alt="首页推荐文章"></p><p><strong>首页推荐文章</strong></p><p><img src="https://statics.sh1a.qingstor.com/2018/12/02/matery-20181202-3.png" alt="首页文章列表"></p><p><strong>首页文章列表</strong></p><p><img src="https://statics.sh1a.qingstor.com/2018/12/02/matery-20181202-7.png" alt="首页文章列表"></p><p><strong>首页文章列表</strong></p><p><img src="https://statics.sh1a.qingstor.com/2018/12/02/matery-20181202-8.png" alt="首页文章列表"></p><p><strong>首页文章列表</strong></p><h2 id="自定制修改"><a href="#自定制修改" class="headerlink" title="自定制修改"></a>自定制修改</h2><p>在本主题的 <code>_config.yml</code> 中可以修改部分自定义信息，有以下几个部分：</p><ul><li>菜单</li><li>我的梦想</li><li>首页的音乐播放器和视频播放器配置</li><li>是否显示推荐文章名称和按钮配置</li><li><code>favicon</code> 和 <code>Logo</code></li><li>个人信息</li><li>TOC 目录</li><li>文章打赏信息</li><li>复制文章内容时追加版权信息</li><li>MathJax</li><li>文章字数统计、阅读时长</li><li>点击页面的’爱心’效果</li><li>我的项目</li><li>我的技能</li><li>我的相册</li><li><code>Gitalk</code>、<code>Gitment</code>、<code>Valine</code> 和 <code>disqus</code> 评论配置</li><li><a href="http://busuanzi.ibruce.info/">不蒜子统计</a>和谷歌分析（<code>Google Analytics</code>）</li><li>默认特色图的集合。当文章没有设置特色图时，本主题会根据文章标题的 <code>hashcode</code> 值取余，来选择展示对应的特色图</li></ul><p><strong>我认为个人博客应该都有自己的风格和特色</strong>。如果本主题中的诸多功能和主题色彩你不满意，可以在主题中自定义修改，很多更自由的功能和细节点的修改难以在主题的 <code>_config.yml</code> 中完成，需要修改源代码才来完成。以下列出了可能对你有用的地方：</p><h3 id="修改主题颜色"><a href="#修改主题颜色" class="headerlink" title="修改主题颜色"></a>修改主题颜色</h3><p>在主题文件的 <code>/source/css/matery.css</code> 文件中，搜索 <code>.bg-color</code> 来修改背景颜色：</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token comment">/* 整体背景颜色，包括导航、移动端的导航、页尾、标签页等的背景颜色. */</span><span class="token selector">.bg-color</span> <span class="token punctuation">&#123;</span>    <span class="token property">background-image</span><span class="token punctuation">:</span> <span class="token function">linear-gradient</span><span class="token punctuation">(</span>to right<span class="token punctuation">,</span> #4cbf30 0%<span class="token punctuation">,</span> #0f9d58 100%<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token atrule"><span class="token rule">@-webkit-keyframes</span> rainbow</span> <span class="token punctuation">&#123;</span>   <span class="token comment">/* 动态切换背景颜色. */</span><span class="token punctuation">&#125;</span><span class="token atrule"><span class="token rule">@keyframes</span> rainbow</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/* 动态切换背景颜色. */</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="修改-banner-图和文章特色图"><a href="#修改-banner-图和文章特色图" class="headerlink" title="修改 banner 图和文章特色图"></a>修改 banner 图和文章特色图</h3><p>你可以直接在 <code>/source/medias/banner</code> 文件夹中更换你喜欢的 <code>banner</code> 图片，主题代码中是每天动态切换一张，只需 <code>7</code> 张即可。如果你会 <code>JavaScript</code> 代码，可以修改成你自己喜欢切换逻辑，如：随机切换等，<code>banner</code> 切换的代码位置在 <code>/layout/_partial/bg-cover-content.ejs</code> 文件的 <code>&lt;script&gt;&lt;/script&gt;</code> 代码中：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'.bg-cover'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">css</span><span class="token punctuation">(</span><span class="token string">'background-image'</span><span class="token punctuation">,</span> <span class="token string">'url(/medias/banner/'</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'.jpg)'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 <code>/source/medias/featureimages</code> 文件夹中默认有 24 张特色图片，你可以再增加或者减少，并需要在 <code>_config.yml</code> 做同步修改。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>git提交删除等操作</title>
      <link href="/2024/10/03/Git-Operational-Commands/"/>
      <url>/2024/10/03/Git-Operational-Commands/</url>
      
        <content type="html"><![CDATA[<h1 id="git提交删除等操作"><a href="#git提交删除等操作" class="headerlink" title="git提交删除等操作"></a>git提交删除等操作</h1><p>同步远程仓库</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> pull<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>确定要提交的范围（.代表全部，有文件名仅提交单个）</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> <span class="token function">add</span> 文件名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除文件需要在写原因之前确定删除的文件，需要选择的范围是全部，添加等操作不需要此操作</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> <span class="token function">rm</span> 文件名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编写此次提交的原因等信息</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">"注释"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>连接对应仓库（origin是笔记本应用盘中的位置，origin2是台式副硬盘中的位置，origin3是笔记本中非系统总盘中的位置，现在已经不需要了）</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> remote <span class="token function">add</span> origin 地址（此仓库为https://gitee.com/hhs1231/c-learning.git）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>提交</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> push<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>并发</title>
      <link href="/2024/10/03/4.Concurrent/"/>
      <url>/2024/10/03/4.Concurrent/</url>
      
        <content type="html"><![CDATA[<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p>ps -ef显示系统中所有进程信息</p><p>ps aux比ps -ef多显示当前进程状态</p><p>top每隔3秒刷新所有进程状态等信息</p><p>进程详细信息在&#x2F;proc中</p><p>nice -n 优先级（-20<del>9，数字越小优先级越低，仅可修改为0</del>9） 进程：更改进程优先级，renice改变已有进程优先级</p><p>fg可让进程从后台运行改为前台运行</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>需要引用unisd.h</p><p>pid_t fork(void);失败会返回-1，成功父进程会返回子进程的进程号，子进程返回0</p><p>可通过fork的返回值区分父进程和子进程</p><p>getpid()获取进程pid</p><p>父进程先结束，子进程会变成孤儿进程被init进程收养，子进程变成后台进程</p><p>子进程先结束，父进程没有及时回收子进程会变成僵尸进程（要避免）</p><p>子进程在fork语句后执行</p><h4 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h4><p>需要引用unisd.h和stdlib.h</p><p>void exit（int status）；</p><p>void _exit（int status）；</p><p>结束进程后会将status返回</p><p>exit结束进程时会刷新缓冲区，_exit会丢弃缓冲区数据</p><h4 id="exec函数族"><a href="#exec函数族" class="headerlink" title="exec函数族"></a>exec函数族</h4><p>需要引用unisd.h</p><p>进程当前内容被指定内容替换</p><p>让父子进程执行不同程序</p><p>int execl（const char *path， const char *arg， 。。。）；</p><p>int execlp（const char *file， const char *arg， 。。。）；</p><p>成功执行指定程序，失败返回EOF</p><p>path执行程序名称和路径</p><p>arg。。。传递给执行程序的参数列表，最后一个一定要是NULL</p><p>file执行程序名称，在PATH中查找</p><p>int execv（const char *path， char  *const argv[]）；</p><p>int execvp（const char *file， char  *const argv[]）；</p><p>成功执行指定程序，失败返回EOF</p><p>arg。。。封装成指针数组，同样最后一个参数为NULL</p><p>需要引用stdlib.h</p><p>int system（const char *command）；</p><p>成功返回命令command的返回值，失败返回EOF</p><h4 id="回收"><a href="#回收" class="headerlink" title="回收"></a>回收</h4><p>子进程由父进程回收</p><p>孤儿进程由init进程回收</p><p>没有及时回收会变成僵尸进程</p><p>需要引用unisd.h</p><p>pid_t wait(int *status);</p><p>成功返回回收的子进程的进程号，失败返回EOF</p><p>子进程没有结束父进程会一直阻塞</p><p>多个子进程哪个先结束哪个先回收</p><p>status保存子进程返回值和结束方式的地址</p><p>status为NULL表示直接释放子进程PCB，不接收返回值</p><p>pid_t waitpid(pid_t pid, int *status, int option);</p><p>成功返回子进程的pid或0，失败返回EOF</p><p>pid指定回收哪个子进程或者任意子进程（-1）</p><p>status保存子进程返回值和结束方式的地址</p><p>option指定回收方式，0（阻塞）或WNOHANG（非阻塞）</p><h4 id="守护进程（Daemon）"><a href="#守护进程（Daemon）" class="headerlink" title="守护进程（Daemon）"></a>守护进程（Daemon）</h4><p>系统启动时运行，系统关闭时结束</p><p>linux很多服务程序以守护进程形式运行</p><p>后台运行，独立于任何终端</p><p>周期性执行某种任务</p><p>会话是一个或多个进程组的集合，每个进程都属于一个进程组</p><h5 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h5><p>子进程创建，父进程退出变成孤儿进程被init进程收养后台运行</p><p>子进程创建新会话变成新会话的组长，这样就脱离了原先的终端</p><p>更改当前工作目录</p><p>守护进程一直在后台运行，工作目录不能被卸载，重新设定当前工作目录cwd</p><p>重设文件权限掩码，文件权限掩码设置为0，只影响当前文件</p><p>关闭当前的文件描述符，关闭所有从父进程继承的打开的文件</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>进程有独立的地址空间</p><p>每个进程都参与内核调度，互不影响</p><p>进程在切换时系统开销大</p><p>轻量级进程LWP为线程</p><p>同一进程中线程共享相同的地址空间</p><h3 id="创建-2"><a href="#创建-2" class="headerlink" title="创建"></a>创建</h3><p>需要引入pthread.h</p><p>int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*routine)(void *), void *arg);成功返回0，失败返回错误码</p><p>thread线程对象</p><p>attr线程属性，NULL表示默认属性</p><p>routine线程执行的函数</p><p>arg传递给routine的参数</p><h3 id="回收-1"><a href="#回收-1" class="headerlink" title="回收"></a>回收</h3><p>需要引入pthread.h</p><p>int pthread_join(pthread_t thread, void **retval);成功返回0，失败返回错误码</p><p>thread要回收的线程对象</p><p>调用线程阻塞直到thread结束</p><p>*retval接收线程的返回值</p><p>void pthread_exit(void *retval);</p><p>结束当前线程</p><p>retval可被其他线程通过pthread_join获取</p><p>线程私有资源会被释放</p><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>有名信号量既可以用在进程之间也可以用在线程之间</p><p>需要引用semaphore.h</p><p>int sem_init(sem_t *sem, int pshared, unsigned int value);</p><p>成功返回0，失败返回EOF</p><p>sem指向要初始化的信号量对象</p><p>pshared 0线程间 1进程间</p><p>val信号量初始值</p><p>int sem_wait(sem_t *sem);P操作</p><p>int sem_post(sem_t *sem);V操作</p><p>成功返回0，失败返回EOF</p><p>sem指向要操作的信号量对象</p><h3 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h3><p>临界资源：一次只允许一个任务访问的共享资源</p><p>临界区</p><p>互斥机制：任务访问临界资源前先申请锁，访问完释放锁</p><p>​mutex互斥锁</p><h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>需要引入pthread.h</p><p>int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr);</p><p>成功返回0，失败返回错误码</p><p>mutex指向要初始化的互斥锁对象</p><p>如果无法获得锁就阻塞任务</p><h5 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h5><p>int pthread_mutex_unlock(pthread_mutex_t *mutex);</p><p>成功返回0，失败返回错误码</p><p>mutex指向要初始化的互斥锁对象</p><p>执行完临界区要及时释放锁</p><h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><h3 id="无名管道"><a href="#无名管道" class="headerlink" title="无名管道"></a>无名管道</h3><p>只能用于有亲缘关系的进程间</p><p>单工通信模式，单向</p><h4 id="创建-3"><a href="#创建-3" class="headerlink" title="创建"></a>创建</h4><p>需要引用unisd.h</p><p>int pipe(int pfd[2]);</p><p>成功返回0，失败返回EOF（-1）</p><p>pfd包含两个元素的整形数组，用于保存文件描述符</p><p>pfd[0]用于读管道, pfd[1]用于写管道</p><p>需要在创建进程前创建管道</p><p>文件一旦读走就不存在了</p><h4 id="读"><a href="#读" class="headerlink" title="读"></a>读</h4><p>当管道中数据量大于读端定义的大小只会读定义的大小对应的数据，否则全读</p><p>如果管道中无数据就返回0</p><h4 id="写"><a href="#写" class="headerlink" title="写"></a>写</h4><p>当空间不足时，会先写满空间然后阻塞写端</p><p>当读端不存在不会写入管道，这种情况叫管道断裂，对应的信号是13&#x2F;d</p><h3 id="有名管道"><a href="#有名管道" class="headerlink" title="有名管道"></a>有名管道</h3><p>需要引用unisd.h和fcntl.h</p><p>int mkfifo(const char *path, mode_t mode);</p><p>成功返回0，失败返回EOF</p><p>path创建管道文件路径</p><p>mode管道文件的权限，如0666</p><p>管道程序永远是0</p><p>必须同时有读端和写端才可以正常运行，否则直接阻塞</p><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>kill -9 -1 很危险，给系统中所有程序发信号</p><p>需要引用unisd.h和signal.h</p><p>int kill(pid_t pid, int sig);</p><p>int raise(int sig);给自己发信号</p><p>成功返回0，失败返回EOF</p><p>pid接收进程的进程号，0代表同组进程，-1代表所有进程</p><p>sig信号类型</p><p>int alarm(unsigned int seconds);定时器（经常用于超时检测）</p><p>成功返回上一个定时器的剩余时间，失败返回EOF</p><p>seconds定时器时间，如果为0代表取消当前定时器</p><p>一个进程只能设定一个定时器，时间到时产生SIGALRM</p><p>int pause(void);让进程睡眠</p><p>进程一直被阻塞，直到被信号中断</p><p>被信号中断后返回-1，errno为EINTR</p><h4 id="设置信号响应方式"><a href="#设置信号响应方式" class="headerlink" title="设置信号响应方式"></a>设置信号响应方式</h4><p>需要引用unisd.h和signal.h</p><p>void (*signal(int signo, void (*handler)(int)))(int);</p><p>成功返回原先的信号处理函数，失败返回SIG_ERR</p><p>signo设置的信号类型</p><p>handler指定的信号处理函数， SIG_DFL代表缺省方式， SIG_IGN代表忽略信号</p><h3 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h3><p>需要引用sys&#x2F;types.h和sys&#x2F;ipc.h</p><p>key_t ftok(const char *path, int proj_id);</p><p>成功返回合法的key值，失败返回EOF</p><p>path存在且可访问的文件的路径</p><p>proj_id用于生成key的数字，不能为0</p><h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><h4 id="创建-4"><a href="#创建-4" class="headerlink" title="创建"></a>创建</h4><p>需要引用sys&#x2F;shm.h和sys&#x2F;ipc.h</p><p>int shmget(key_t key, int size, int shmflg);</p><p>成功返回共享内存id，失败返回EOF</p><p>key是和共享内存关联的key，由IPC_PRIVATE（私有）或ftok生成的地址</p><p>shmflg共享内存标志位IPC_CREAT（私有可以没有IPC_CREAT）|0666</p><h4 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h4><p>需要引用sys&#x2F;shm.h和sys&#x2F;ipc.h</p><p>void *shmat(int shmid, const void *shmaddr, int shmflg);映射后可像访问正常地址一样访问</p><p>成功返回映射后的地址，失败返回(void *)-1</p><p>shmid要映射的共享内存id</p><p>shmaddr映射后的地址，NULL由系统自动映射</p><p>shmflg标志位， 0表示可读写，SHM_RDONLY表示只读</p><h4 id="撤销映射"><a href="#撤销映射" class="headerlink" title="撤销映射"></a>撤销映射</h4><p>需要引用sys&#x2F;shm.h和sys&#x2F;ipc.h</p><p>int shmdt(void *shmaddr)；</p><p>成功返回0，失败返回EOF</p><p>不使用共享内存时应及时撤销映射，进程结束系统会自动撤销</p><h4 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h4><p>需要引用sys&#x2F;shm.h和sys&#x2F;ipc.h</p><p>int shmctl(int shmid, int cmd, struct shmid_ds *buf);</p><p>成功返回0，失败返回EOF</p><p>shmid要操作的共享内存id</p><p>cmd要执行的操作IPC_STAT（获取共享内存属性） IPC_SET（设置共享内存属性） IPC_RMID（删除共享内存id，buf可设置为NULL）</p><p>buf结构体指针，保存或设置共享内存属性的地址</p><p>ipcs -l查看共享内存大小等信息</p><p>cat &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;shmmax设定共享内存大小等信息</p><p>shmctl仅添加标记，当所有映射该共享内存的进程都取消映射后再删除，nattach记录映射该共享内存的进程数</p><h3 id="消息队列-和共享内存函数有一定的相似度"><a href="#消息队列-和共享内存函数有一定的相似度" class="headerlink" title="消息队列(和共享内存函数有一定的相似度)"></a>消息队列(和共享内存函数有一定的相似度)</h3><h4 id="创建-打开"><a href="#创建-打开" class="headerlink" title="创建&#x2F;打开"></a>创建&#x2F;打开</h4><p>需要引用sys&#x2F;msg.h和sys&#x2F;ipc.h</p><p>int msgget(key_t key, int msgflg);</p><p>成功返回消息队列id，失败返回EOF</p><p>key是和消息队列关联的key，由IPC_PRIVATE（私有）或ftok生成的地址</p><p>msgflg标志位 IPC_CREAT（私有可以没有IPC_CREAT）|0666</p><h4 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h4><p>需要引用sys&#x2F;msg.h和sys&#x2F;ipc.h</p><p>int msgsnd(int msgid， const void *msgp, size_t size, int msgflg);</p><p>成功返回0，失败返回-1</p><p>msgid消息队列id</p><p>msgp消息缓冲区地址</p><p>size消息正文长度</p><p>msgflg标志位 0或IPC_NOWAIT（不论消息是否发送成功都返回）</p><h4 id="接收消息"><a href="#接收消息" class="headerlink" title="接收消息"></a>接收消息</h4><p>需要引用sys&#x2F;msg.h和sys&#x2F;ipc.h</p><p>int msgrcv(int msgid， const void *msgp, size_t size, long msgtype, int msgflg);</p><p>成功返回收到的消息长度，失败返回-1</p><p>msgid消息队列id</p><p>msgp消息缓冲区地址</p><p>size接收的消息长度</p><p>msgtype指定接收的消息类型 0为接收最早的消息</p><p>msgflg标志位 0或IPC_NOWAIT（不论消息是否接收成功都返回，不成功返回错误）</p><h4 id="控制消息队列"><a href="#控制消息队列" class="headerlink" title="控制消息队列"></a>控制消息队列</h4><p>需要引用sys&#x2F;msg.h和sys&#x2F;ipc.h</p><p>int msgctl(int msgid, int cmd, struct msqid_ds *buf);</p><p>成功返回0，失败返回-1</p><p>msgid消息队列id</p><p>cmd要执行的操作 IPC_STAT&#x2F;IPC_SET&#x2F;IPC_RMID</p><h3 id="System-V-信号灯"><a href="#System-V-信号灯" class="headerlink" title="System V 信号灯"></a>System V 信号灯</h3><h4 id="创建-打开-1"><a href="#创建-打开-1" class="headerlink" title="创建&#x2F;打开"></a>创建&#x2F;打开</h4><p>需要引用sys&#x2F;sem.h和sys&#x2F;ipc.h</p><p>int semget(key_t key, int nsems, int semflg);</p><p>成功返回信号灯id，失败返回-1</p><p>key是和消息队列关联的key，由IPC_PRIVATE（私有）或ftok生成的地址</p><p>nsems集合中包含的计数信号灯个数</p><p>semflg标志位 IPC_CREAT|0666 | IPC_EXCL（检查对象是否存在）</p><h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4><p>需要引用sys&#x2F;sem.h和sys&#x2F;ipc.h</p><p>int semctl(int semid, int semnum, int cmd, …);</p><p>成功返回0，失败返回EOF</p><p>semid要操作的信号灯集id</p><p>semnum要操作的集合中的信号灯编号</p><p>cmd执行的操作 SETVAL（需要加第四个参数union semun） IPC_RMID</p><p>union semun（需要自己定义）取决于cmd</p><h4 id="P-V操作"><a href="#P-V操作" class="headerlink" title="P&#x2F;V操作"></a>P&#x2F;V操作</h4><p>需要引用sys&#x2F;sem.h和sys&#x2F;ipc.h</p><p>int semop(int semid, struct sembuf *sops, unsigned nsops);</p><p>成功返回0，失败返回-1</p><p>semid要操作的信号灯集id</p><p>sops描述对信号灯操作的结构体（数组）</p><p>nsops要操作的信号灯个数</p><p>struct sembuf</p><p>{</p><p>​short semnum;</p><p>​short sem_op;</p><p>​short sem_flg;</p><p>}</p><p>semnum信号灯编号</p><p>sem_op：-1-P操作&#x2F;1-V操作</p><p>sem_flg：0&#x2F;IPC_NOWAIT</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>基础部分笔记</title>
      <link href="/2024/10/03/1.C-Basics-Section/"/>
      <url>/2024/10/03/1.C-Basics-Section/</url>
      
        <content type="html"><![CDATA[<h1 id="基础部分笔记"><a href="#基础部分笔记" class="headerlink" title="基础部分笔记"></a>基础部分笔记</h1><h3 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1.数据类型"></a>1.数据类型</h3><h5 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h5><h6 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h6><p>整型可分为有符号（signed）和无符号（unsigned），short（2byte）、int（4byte）、long（4byte）</p><h6 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h6><p>float（4byte）、double（8byte）</p><h6 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h6><p>char（1byte）</p><h5 id="构造类型"><a href="#构造类型" class="headerlink" title="构造类型"></a>构造类型</h5><h6 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h6><h6 id="结构体struct"><a href="#结构体struct" class="headerlink" title="结构体struct"></a>结构体struct</h6><h6 id="共用体union"><a href="#共用体union" class="headerlink" title="共用体union"></a>共用体union</h6><h6 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h6><h5 id="各数据类型精度"><a href="#各数据类型精度" class="headerlink" title="各数据类型精度"></a>各数据类型精度</h5><table><thead><tr><th align="left">类型</th><th align="left">存储大小</th><th align="left">值范围</th></tr></thead><tbody><tr><td align="left">char</td><td align="left">1 字节</td><td align="left">-128 到 127 或 0 到 255</td></tr><tr><td align="left">unsigned char</td><td align="left">1 字节</td><td align="left">0 到 255</td></tr><tr><td align="left">signed char</td><td align="left">1 字节</td><td align="left">-128 到 127</td></tr><tr><td align="left">int</td><td align="left">2 或 4 字节</td><td align="left">-32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647</td></tr><tr><td align="left">unsigned int</td><td align="left">2 或 4 字节</td><td align="left">0 到 65,535 或 0 到 4,294,967,295</td></tr><tr><td align="left">short</td><td align="left">2 字节</td><td align="left">-32,768 到 32,767</td></tr><tr><td align="left">unsigned short</td><td align="left">2 字节</td><td align="left">0 到 65,535</td></tr><tr><td align="left">long</td><td align="left">4 字节</td><td align="left">-2,147,483,648 到 2,147,483,647</td></tr><tr><td align="left">unsigned long</td><td align="left">4 字节</td><td align="left">0 到 4,294,967,295</td></tr></tbody></table><p>范围可在&#x2F;usr&#x2F;include&#x2F;limits.h中查询</p><p>查看ASCII码：man ASCII</p><h3 id="2-存储类型"><a href="#2-存储类型" class="headerlink" title="2.存储类型"></a>2.存储类型</h3><p><a href="https://hhs1231.gitlab.io/2024/10/03/1.C-Basics-Section/001.png">The page you’re looking for could not be found (404) (hhs1231.gitlab.io)</a></p><h5 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h5><p>范围变量，局部，默认是随机值，默认存储类型</p><h5 id="register"><a href="#register" class="headerlink" title="register"></a>register</h5><p>寄存器型，将变量放入CPU的寄存器中加快程序运行速度。寄存器变量不可用地址，申请不到就使用一般内存，同auto</p><h5 id="static"><a href="#static" class="headerlink" title="static"></a>static</h5><p>静态存储型变量，创建后生命周期直到程序结束，固定地址存放，不是堆栈存放，默认为0</p><h5 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h5><p>全局变量，可在函数体外说明，也可在外部（其他文件）使用，编译时需要带着extern修饰的变量所在的文件，原文件无需使用extern，引用文件需要使用extern修饰该变量</p><h3 id="3-运算符优先级"><a href="#3-运算符优先级" class="headerlink" title="3.运算符优先级"></a>3.运算符优先级</h3><p>z&#x3D;(x+&#x3D;1,y-&#x3D;10);z的值最终会是y-&#x3D;10的值</p><p><img src="/images/1.C-Basics-Section/001.png"></p><p><img src="/images/1.C-Basics-Section/002.png"></p><p><img src="/images/1.C-Basics-Section/003.png"></p><p><img src="/images/1.C-Basics-Section/all.jpg" alt="运算符优先级表"></p><h3 id="4-输入输出函数"><a href="#4-输入输出函数" class="headerlink" title="4.输入输出函数"></a>4.输入输出函数</h3><h4 id="输出函数"><a href="#输出函数" class="headerlink" title="输出函数"></a>输出函数</h4><p>putchar(int c)；输出ASCII码中对应是字符，也可直接传入字符</p><h5 id="格式字符"><a href="#格式字符" class="headerlink" title="格式字符"></a>格式字符</h5><p><strong>1.d 格式字符</strong><br>功能：用来输出十<a href="https://so.csdn.net/so/search?q=%E8%BF%9B%E5%88%B6&spm=1001.2101.3001.7020">进制</a>数<br>格式：%d：按<a href="https://so.csdn.net/so/search?q=%E6%95%B4%E5%9E%8B&spm=1001.2101.3001.7020">整型</a>数据的实际长度输出<br>%md：m 为指定的输出字段的宽度。如果数据的位数小于 m，则左端补一空格；若大于 m，则按实际位数输出。<br>%ld：输出长整型数据。</p><p><strong>2.o 格式字符</strong><br>功能：以八进制形式输出整数；<br>格式：%o：按整型数据的实际长度输出<br>%mo：m 为指定的输出字段的宽度。如果数据的位数小于 m，则左端补一空格；若大于 m，则按实际位数输出。<br>%lo：输出长整型数据。</p><p><strong>3.x 格式字符</strong><br>功能：以十六进制形式输出整数<br>格式:%x：按整型数据的实际长度输出<br>%mx：m 为指定的输出字段的宽度。如果数据的位数小于 m，则左端补一空格；若大于 m，则按实际位数输出。<br>%lx：输出长整型数据。</p><p><strong>4.u 格式字符</strong><br>功能：以十进制数输出无符号整数<br>格式：%u：按整型数据的实际长度输出<br>%mu：m 为指定的输出字段的宽度。如果数据的位数小于 m，则左端补一空格；若大于 m，则按实际位数输出。<br>%lu：输出长整型数据。</p><p><strong>5.c 格式字符</strong> **<br>功能：输出单个字符<br>格式：%c：按整型数据的实际长度输出<br>%mc：m 为指定的输出字段的宽度。如果数据的位数小于 m，则左端补一空格；若大于 m，则按实际位数输出。<br>%lc：输出长整型数据。</p><p><strong>6.s 格式字符</strong><br>功能：输出字符串<br>格式：%s：按整型数据的实际长度输出<br>%ms：m 为指定的输出字段的宽度。如果数据的位数小于 m，则左端补一空格；若大于 m，则按实际位数输出。<br>%ls：输出长整型数据。</p><p><strong>7.f 格式字符</strong><br>功能：以小数形式输出单、双精度实数<br>格式：%f：按整型数据的实际长度输出<br>%mf：m 为指定的输出字段的宽度。如果数据的位数小于 m，则左端补一空格；若大于 m，则按实际位数输出。<br>%lf：输出长整型数据。</p><p><strong>8.e 格式字符</strong><br>功能：以指数形式输出单、双精度实数<br>格式：%e：按整型数据的实际长度输出<br>%me：m 为指定的输出字段的宽度。如果数据的位数小于 m，则左端补一空格；若大于 m，则按实际位数输出。<br>%le：输出长整型数据。</p><p><strong>9.g 格式字符</strong><br>功能：以 %f、%e 中较短的输出宽度输出单、双精度实数<br>格式：%g：按整型数据的实际长度输出<br>%mg：m 为指定的输出字段的宽度。如果数据的位数小于 m，则左端补一空格；若大于 m，则按实际位数输出。<br>%lg：输出长整型数据。</p><p>gets(字符数组);会自动换行</p><p>%p获取变量地址</p><h4 id="输入函数"><a href="#输入函数" class="headerlink" title="输入函数"></a>输入函数</h4><p>getchar()；获取输入的字符【ctrl+d打印出来会是-1】</p><p>想检验输入是否成功可以  n&#x3D;scanf(“%d”,&amp;ch);n的值就代表输入成功了几个数据</p><p>%*d:输入的这个值不会赋给变量，会直接抛弃</p><p>字符型赋值不可用空格、回车进行分割，空格、回车会自动识别成字符，若需要空格、回车进行分割可以使用getchar()对空格、回车这个垃圾字符进行回收，也可使用%*c</p><p>%s会将空格、回车视为截止</p><p>gets(字符数组);可从键盘输入获取字符填入字符数组（只能输入字符数组长度-1），但很危险，如果输入超过了字符数组长度会导致栈溢出（空格会作为字符存入字符数组）</p><h3 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h3><h5 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h5><p>gcc数组下标越界不做检查，数组不做初始化会是随机值，数组不赋值默认为0</p><p>数组长度：sizeof(数组)&#x2F;sizeof(数组数据类型)</p><h5 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h5><p>数组长度计算，行：sizeof(数组)&#x2F;sizeof(单行数组)</p><p>​     列：sizeof(单行数组)&#x2F;sizeof(数据类型)</p><h5 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h5><p>字符数组中若没有’\0’，%s会打印到’\0’为止，结果会出现异常</p><p>字符数组可填入字符串，会自动分为字符，最后一个字符会是’\0’，若字符串长度不够会用’\0’填充</p><h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><h5 id="strlen函数"><a href="#strlen函数" class="headerlink" title="strlen函数"></a>strlen函数</h5><p>获取字符串有效长度（看到’\0’截止，’\0’不计入长度）</p><h5 id="strcpy函数"><a href="#strcpy函数" class="headerlink" title="strcpy函数"></a>strcpy函数</h5><p>字符串拷贝，strncpy(p,p1,n)复制指定长度的字符串，p1前n个字符会被p中前n个字符覆盖</p><p>strncat(p,p1,n)函数是在后面填充n个字符</p><p>strchr(s1,n)正向查找</p><p>strrchr反向查找</p><p>isalpha(P)判断是否为字符</p><p>isupper(p)判断是否为大写</p><p>islower(p)判断是否为小写</p><h1 id="shell命令"><a href="#shell命令" class="headerlink" title="shell命令"></a>shell命令</h1><p>&#x2F;bin&#x2F;bash 换行使用-n</p><p>&#x2F;bin&#x2F;sh 换行使用&#x2F;c</p><p>free(P)会将P指向的堆空间释放，让P变为空悬指针（野指针），这样很危险，后面要让P指向NULL防止出现问题</p><p>指针指向的变量未初始化或者指针操作超越了变量的作用范围（例如数组下标超限），这样的指针是野指针（危险）</p><p>局部变量会跟随函数结束而销毁，如果后续还需要使用则要将这个变量变成静态变量（static）</p><p>指针在函数中赋值字符串常量无法传递给主函数，会造成内存泄漏，字符串常量赋给指针需要在对应（需要使用的）函数中进行</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/2024/10/03/2.Data-Structure/"/>
      <url>/2024/10/03/2.Data-Structure/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>perror打印错误信息</p><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p>结构体定义可放于.h，在对应程序引用</p><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>当编译器输入不是想要的数据类型，该数据会变成脏数据，如果是循环中发生会导致持续读取到该脏数据</p><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>度：结点的子树个数</p><p>结点的度个数最多的就是整个树的度</p><p>深度：树的分支中元素最多的就是该树的深度</p><p>父节点：某个结点的上一级</p><p>兄弟结点：同一层级的几个结点之间互为兄弟结点</p><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>数和二叉树的区别是结构类似的情况，树是相同的，二叉树是不同的</p><p>满二叉树每层结点个数为2的（n-1）次方，结点数为2的n次方减一个</p><p>度为0的结点总是比度为2的结点多一个</p><p>完全二叉树对比满二叉树的区别为最下面的结点少若干个（全无也可以），满二叉树也是特殊的完全二叉树</p><p>完全二叉树的深度为n时，结点数为log（</p><h4 id="二叉树的顺序存储结构（浪费空间）"><a href="#二叉树的顺序存储结构（浪费空间）" class="headerlink" title="二叉树的顺序存储结构（浪费空间）"></a>二叉树的顺序存储结构（浪费空间）</h4><p>申请连续的存储空间；不是完全二叉树补成完全二叉树；按从左往右、从上到下编号；按编号存储到连续空间中，结点为虚节点（没有的）的用特殊符号标识</p><h4 id="二叉树的链式存储结构（保存数据可用栈）"><a href="#二叉树的链式存储结构（保存数据可用栈）" class="headerlink" title="二叉树的链式存储结构（保存数据可用栈）"></a>二叉树的链式存储结构（保存数据可用栈）</h4><p>左子树地址&#x2F;数据&#x2F;右子树地址</p><p>遍历方式：上到下（较复杂，需要使用队列，存在左&#x2F;右结点就放入队列），左到右（用的多，非递归方式为根结点和左结点先输出，右结点先放入栈中后续再取出执行，需要欧用循环），右到左</p><p>输入二叉树结构和顺序存储差不多，用前序序列，没有结点的用#代替</p><h4 id="序列（前中后序列与根的位置有关）"><a href="#序列（前中后序列与根的位置有关）" class="headerlink" title="序列（前中后序列与根的位置有关）"></a>序列（前中后序列与根的位置有关）</h4><p>前序序列：根左右</p><p>中序序列：左根右</p><p>后序序列：左右根</p><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h3 id="顺序查找（比较浪费）"><a href="#顺序查找（比较浪费）" class="headerlink" title="顺序查找（比较浪费）"></a>顺序查找（比较浪费）</h3><p>多次比较的基础上实现的</p><h3 id="折半查找（适合顺序排列）"><a href="#折半查找（适合顺序排列）" class="headerlink" title="折半查找（适合顺序排列）"></a>折半查找（适合顺序排列）</h3><p>多次比较，但优于顺序查找</p><h3 id="hash查找"><a href="#hash查找" class="headerlink" title="hash查找"></a>hash查找</h3><p>容易产生冲突，重点是解决冲突</p><p>核心是在hash表中找空位放置元素</p><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><h6 id="直接定址法"><a href="#直接定址法" class="headerlink" title="直接定址法"></a>直接定址法</h6><p>元素加上一个常量存储</p><h6 id="除留余数法（用的多）"><a href="#除留余数法（用的多）" class="headerlink" title="除留余数法（用的多）"></a>除留余数法（用的多）</h6><p>对hash表长度取余存储</p><h6 id="数字分析法（较麻烦，不太合适）"><a href="#数字分析法（较麻烦，不太合适）" class="headerlink" title="数字分析法（较麻烦，不太合适）"></a>数字分析法（较麻烦，不太合适）</h6><p>对所有元素进行分析，对取值不集中的两位做地址</p><h6 id="平方取中法"><a href="#平方取中法" class="headerlink" title="平方取中法"></a>平方取中法</h6><p>对元素进行平方，选取中间几位做地址</p><h6 id="折叠法"><a href="#折叠法" class="headerlink" title="折叠法"></a>折叠法</h6><p>将元素分成几段，将这几段相加得地址</p><h6 id="随机乘数法"><a href="#随机乘数法" class="headerlink" title="随机乘数法"></a>随机乘数法</h6><p>将元素和随机的0-1之间的数相乘，获取小数部分和hash表长度相乘，得地址</p><h6 id="基数转换法"><a href="#基数转换法" class="headerlink" title="基数转换法"></a>基数转换法</h6><p>将元素进制进行更换，选取其中部分作为地址</p><h4 id="解决冲突的办法"><a href="#解决冲突的办法" class="headerlink" title="解决冲突的办法"></a>解决冲突的办法</h4><h5 id="开放地址法"><a href="#开放地址法" class="headerlink" title="开放地址法"></a>开放地址法</h5><p>存放函数为除留余数法</p><h6 id="线性探测法"><a href="#线性探测法" class="headerlink" title="线性探测法"></a>线性探测法</h6><p>依次加一寻找空位</p><h6 id="二次探测法"><a href="#二次探测法" class="headerlink" title="二次探测法"></a>二次探测法</h6><p>在冲突位左右寻空位，先加后减</p><h5 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h5><p>存放函数是除留余数法</p><p>该方法解决冲突的办法是对有冲突的元素放入一个链表</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>稳定排序与非稳定排序的区别是数据相同的两个元素是否按原顺序排列</p><p>内排序与外排序的区别是数据是否在原位置排列（内排序常见）</p><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><p>一个个比较</p><h3 id="shell排序"><a href="#shell排序" class="headerlink" title="shell排序"></a>shell排序</h3><p>基于直接插入排序</p><p>将数组变为n段排序，后续不断把n除2</p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>将其中一个元素拿去和最后面&#x2F;最前面比较，需要交换就换，不需要交换就向后&#x2F;向前移动再次比较，一次比较能获得一次基准，将数组分为两部分，再次用这个方法对两部分进行排序直到排好序</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>IO</title>
      <link href="/2024/10/03/3.IO/"/>
      <url>/2024/10/03/3.IO/</url>
      
        <content type="html"><![CDATA[<h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><p>标准IO：通过缓冲（缓存）减少系统调用，提高效率</p><p>无系统代码直接调用硬件，有系统用系统</p><h2 id="流（标准IO）"><a href="#流（标准IO）" class="headerlink" title="流（标准IO）"></a>流（标准IO）</h2><p>c标准定义</p><p>linux最多能自建1021个流，加上预定义3个流刚好为1024</p><p>标准IO预定义3个流</p><p>标准输入流stdin &#x2F; 标准输出流stdout &#x2F; 标准错误流stderr</p><h3 id="文本流"><a href="#文本流" class="headerlink" title="文本流"></a>文本流</h3><p>windows：换行符对应‘&#x2F;r’ ‘&#x2F;n’</p><p>linux：换行符对应‘&#x2F;n’</p><h3 id="二进制流"><a href="#二进制流" class="headerlink" title="二进制流"></a>二进制流</h3><p>windows：换行符对应‘&#x2F;n’</p><p>linux：换行符对应‘&#x2F;n’</p><h3 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h3><h4 id="全缓冲（打开默认文件）"><a href="#全缓冲（打开默认文件）" class="headerlink" title="全缓冲（打开默认文件）"></a>全缓冲（打开默认文件）</h4><p>当缓冲区无数据&#x2F;无空间才执行IO操作</p><h4 id="行缓冲"><a href="#行缓冲" class="headerlink" title="行缓冲"></a>行缓冲</h4><p>输入输出遇到换行符执行IO操作</p><p>流与一个终端关联时是典型的行缓冲</p><p>代码中打印信息最好加上换行符</p><h4 id="无缓冲"><a href="#无缓冲" class="headerlink" title="无缓冲"></a>无缓冲</h4><p>错误信息</p><h3 id="打开流"><a href="#打开流" class="headerlink" title="打开流"></a>打开流</h3><p>FILE *fopen（const char *path， const char *mode）；成功返回流指针，错误返回空</p><p>r（文本）&#x2F;rb（二进制）：只读，必须有这个文件</p><p>r+（文本）&#x2F;r+b（二进制）：读写，必须有这个文件</p><p>w（文本）&#x2F;wb（二进制）：只写，有则清空文件，无则创建</p><p>w+（文本）&#x2F;w+b（二进制）：读写，其余同w</p><p>a（文本）&#x2F;ab（二进制）：只写，无则创建，有则末尾添加内容</p><p>a+（文本）&#x2F;a+b（二进制）：读写，其余同a</p><p>fopen创建文件权限为0666（rw-rw-rw-），linux有umask（（022）&amp;创建文件的权限）控制权限</p><p>用户可以更改umask，但仅影响当前文件</p><h3 id="处理错误信息"><a href="#处理错误信息" class="headerlink" title="处理错误信息"></a>处理错误信息</h3><p>extern int errno；存放错误号</p><p>void perror（const char *s）；先输出s，再输出错误号对应错误信息</p><p>char *strerror（int errno）；根据错误号返回对应错误信息</p><h3 id="关闭流"><a href="#关闭流" class="headerlink" title="关闭流"></a>关闭流</h3><p>int fclose（FILE *stream）；成功返回0，失败返回EOF并设置errno</p><p>流关闭会自动刷新缓冲中的数据并释放缓冲区</p><p>程序正常终止会自动关闭所有流</p><p>关闭流后不可再去访问</p><h3 id="读写流（错误或返回为EOF（-1））"><a href="#读写流（错误或返回为EOF（-1））" class="headerlink" title="读写流（错误或返回为EOF（-1））"></a>读写流（错误或返回为EOF（-1））</h3><p>fgetc（）读一个字符&#x2F;fputc（）写一个字符    效率低</p><p>fgets（）读一行&#x2F;fputs（）写一行            适用文本文件（二进制文件会出问题）</p><p><strong>fread（）读若干对象&#x2F;fwrite（）写若干对象   文本文件和二进制文件都适用（推荐使用）</strong></p><p>diff -ruN用于比较文本文件</p><p>gets（）容易造成缓冲区溢出</p><p>fgets()读完会在最后添加‘&#x2F;0’结尾，换行符也会保留，当内容放不下时会读取size-1个字符，最后一位存‘&#x2F;0’</p><p>puts()在输出完后会追加‘&#x2F;n’，fputs（）不会</p><h3 id="刷新流"><a href="#刷新流" class="headerlink" title="刷新流"></a>刷新流</h3><p>当缓冲区满时系统会自动刷新</p><p>int fflush（FILE *fp）；成功返回0，失败返回EOF（-1）</p><p>linux只能刷新缓冲区，将内容存入文件</p><h3 id="定位流"><a href="#定位流" class="headerlink" title="定位流"></a>定位流</h3><p>long ftell（FILE *stream）；成功返回读写位置，失败返回EOF（-1）</p><p>long fseek（FILE *stream， long offset， int whence）；成功返回0，失败返回EOF（-1），whence是设置基准点，SEEK_SET开始位置&#x2F;SEEK_CUR当前位置&#x2F;SEEK_END结束位置</p><p>void rewind（FILE *stream）；定位到开始位置</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>int ferror（FILE *stream）；返回1代表流出错</p><p>int feof（FILE *stream）；返回1代表到文件末尾</p><h3 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h3><p>int fprintf（FILE *stream， const char *fmt， 。。。）；将内容输出到流中</p><p>int sprintf（char *s， const char *fmt， 。。。）；将内容输出到缓冲区中</p><p>sleep函数在unisd.h中，使用该函数需要引用这个文件</p><p>使用时间需要精确到秒就需要引入time.h</p><p>使用字符串需要引用string.h</p><p>%02d代表该数据占两位</p><h2 id="文件IO"><a href="#文件IO" class="headerlink" title="文件IO"></a>文件IO</h2><p>遵循操作系统标准，无缓冲，通过文件描述符打开文件，使用更加广泛</p><p>标准IO基于文件IO</p><p>打开文件需要引用fcntl.h</p><p>int open（const char *path， int oflag， 。。。）；打开文件，成功返回文件描述符，失败返回EOF（-1）；仅打开只需两个参数，创建需要用到三个参数</p><p>关闭&#x2F;读取&#x2F;写入&#x2F;定位文件需要引用unistd.h</p><p>int close（int fd）；成功返回0，失败返回EOF（-1）</p><p>关闭后文件描述符不再代表文件</p><p>ssize_t read(int fd, void *buf, size_t count);成功返回实际读取字节数，失败返回EOF（-1），读到末尾返回0；buf是缓冲区大小，count不能超过buf大小</p><p>ssize_t write(int fd, void *buf, size_t count);成功返回实际写入字节数大小，失败返回EOF（-1）；buf是缓冲区大小，count不能超过buf大小</p><p>off_t Iseek(int fd, off_t offset, intt whence)；成功返回当前文件读写位置，失败返回EOF（-1）；后两个参数和标准IO的定位函数中一致</p><p>访问&#x2F;关闭目录需要引用dirent.h</p><p>DIR *opendir（const char *name）；</p><p>DIR为描述一个打开的目录文件的结构体类型</p><p>成功返回目录流指针，失败返回EOF（-1）</p><p>struct dirent *readdir（DIR *dirp）；读取目录中的内容</p><p>struct dirent用于描述目录流中一个目录项的结构体类型</p><p>成功返回目录流dirp中下一个目录项，失败返回NULL</p><p>int closedir（DIR *dirp）；成功返回0，失败返回EOF(-1)</p><p>修改文件访问权限&#x2F;获取文件属性需要引用sys&#x2F;stat.h</p><p>int chmod(const char *path, mode_t mode);通过路径修改权限</p><p>int fchmod(int fd, mode_t mode);通过文件描述符修改权限</p><p>成功返回0，失败返回EOF（-1）</p><p>root和文件所有者可修改文件访问权限</p><p>int stat（const char *path， struct stat *buf）；获取符号链接的目标文件的属性</p><p>int Istat（const char *path， struct stat *buf）；获取符号链接的文件的属性</p><p>int fstat（int fd， struct stat *buf）；</p><p>成功返回0，失败返回EOF（-1）</p><p>自编写的库在编译时需要在命令后添加 -L位置 -l函数名</p><p>-fPIC文件位置不固定，.a是静态库，.so.X是共享库（动态库）</p><p>共享库需要编辑环境中的路径或者在&#x2F;etc&#x2F;ld.so.conf.d&#x2F;下添加一个conf结尾的文件，执行ldconfig刷新</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
